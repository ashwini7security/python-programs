The system is: Linux - 2.6.32-5-amd64 - x86_64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/gcc 
Build flags: 
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/g++ 
Build flags: 
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2849464963/fast"
make -f CMakeFiles/cmTryCompileExec2849464963.dir/build.make CMakeFiles/cmTryCompileExec2849464963.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2849464963.dir/testCCompiler.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2849464963.dir/testCCompiler.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec2849464963
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2849464963.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2849464963.dir/testCCompiler.c.o  -o cmTryCompileExec2849464963 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4288529067/fast"
make -f CMakeFiles/cmTryCompileExec4288529067.dir/build.make CMakeFiles/cmTryCompileExec4288529067.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec4288529067
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4288529067.dir/link.txt --verbose=1
/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec4288529067 -rdynamic  
Using built-in specs.
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.4.5 (Debian 4.4.5-8) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../:/lib/:/usr/lib/:/usr/lib/x86_64-linux-gnu/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec4288529067' '-rdynamic' '-mtune=generic'
 /usr/lib/gcc/x86_64-linux-gnu/4.4.5/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec4288529067 /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../.. -L/usr/lib/x86_64-linux-gnu CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crtn.o
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec4288529067/fast"]
  ignore line: [make -f CMakeFiles/cmTryCompileExec4288529067.dir/build.make CMakeFiles/cmTryCompileExec4288529067.dir/build]
  ignore line: [make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp']
  ignore line: [/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec4288529067]
  ignore line: [/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4288529067.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/gcc       -v CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec4288529067 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.4.5 (Debian 4.4.5-8) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../:/lib/:/usr/lib/:/usr/lib/x86_64-linux-gnu/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec4288529067' '-rdynamic' '-mtune=generic']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.4.5/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec4288529067 /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../.. -L/usr/lib/x86_64-linux-gnu CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/collect2] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=both] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec4288529067] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../..]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [CMakeFiles/cmTryCompileExec4288529067.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib] ==> [/usr/lib]
  collapse dir [/lib/../lib] ==> [/lib]
  collapse dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../..] ==> [/usr/lib]
  collapse dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  implicit libs: [c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.4.5;/usr/lib;/lib;/usr/lib/x86_64-linux-gnu]


Determining if the CXX compiler works passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec395582066/fast"
make -f CMakeFiles/cmTryCompileExec395582066.dir/build.make CMakeFiles/cmTryCompileExec395582066.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec395582066.dir/testCXXCompiler.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec395582066.dir/testCXXCompiler.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec395582066
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec395582066.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec395582066.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec395582066 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2367434572/fast"
make -f CMakeFiles/cmTryCompileExec2367434572.dir/build.make CMakeFiles/cmTryCompileExec2367434572.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec2367434572
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2367434572.dir/link.txt --verbose=1
/usr/bin/g++        -v CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2367434572 -rdynamic  
Using built-in specs.
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.4.5 (Debian 4.4.5-8) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../:/lib/:/usr/lib/:/usr/lib/x86_64-linux-gnu/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2367434572' '-rdynamic' '-shared-libgcc' '-mtune=generic'
 /usr/lib/gcc/x86_64-linux-gnu/4.4.5/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec2367434572 /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../.. -L/usr/lib/x86_64-linux-gnu CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crtn.o
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec2367434572/fast"]
  ignore line: [make -f CMakeFiles/cmTryCompileExec2367434572.dir/build.make CMakeFiles/cmTryCompileExec2367434572.dir/build]
  ignore line: [make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp']
  ignore line: [/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec2367434572]
  ignore line: [/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2367434572.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/g++        -v CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2367434572 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.4.5 (Debian 4.4.5-8) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../:/lib/:/usr/lib/:/usr/lib/x86_64-linux-gnu/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2367434572' '-rdynamic' '-shared-libgcc' '-mtune=generic']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.4.5/collect2 --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=both -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec2367434572 /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5 -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../.. -L/usr/lib/x86_64-linux-gnu CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/collect2] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=both] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec2367434572] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../..]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [CMakeFiles/cmTryCompileExec2367434572.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib/crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.4.5]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../../lib] ==> [/usr/lib]
  collapse dir [/lib/../lib] ==> [/lib]
  collapse dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse dir [/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../..] ==> [/usr/lib]
  collapse dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.4.5;/usr/lib;/lib;/usr/lib/x86_64-linux-gnu]


Determining if the include file iostream exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2062998694/fast"
make -f CMakeFiles/cmTryCompileExec2062998694.dir/build.make CMakeFiles/cmTryCompileExec2062998694.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2062998694.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2062998694.dir/CheckIncludeFile.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec2062998694
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2062998694.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec2062998694.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec2062998694 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec909241405/fast"
make -f CMakeFiles/cmTryCompileExec909241405.dir/build.make CMakeFiles/cmTryCompileExec909241405.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec909241405.dir/TestForSTDNamespace.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec909241405.dir/TestForSTDNamespace.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec909241405
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec909241405.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec909241405.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec909241405 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec170780593/fast"
make -f CMakeFiles/cmTryCompileExec170780593.dir/build.make CMakeFiles/cmTryCompileExec170780593.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec170780593.dir/TestForAnsiForScope.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec170780593.dir/TestForAnsiForScope.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec170780593
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec170780593.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec170780593.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec170780593 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec952545176/fast"
make -f CMakeFiles/cmTryCompileExec952545176.dir/build.make CMakeFiles/cmTryCompileExec952545176.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec952545176.dir/TestForSSTREAM.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec952545176.dir/TestForSSTREAM.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec952545176
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec952545176.dir/link.txt --verbose=1
/usr/bin/g++           CMakeFiles/cmTryCompileExec952545176.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec952545176 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec473545124/fast"
make -f CMakeFiles/cmTryCompileExec473545124.dir/build.make CMakeFiles/cmTryCompileExec473545124.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec473545124.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec473545124.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec473545124
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec473545124.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec473545124.dir/CheckSymbolExists.c.o  -o cmTryCompileExec473545124 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2568490081/fast"
make -f CMakeFiles/cmTryCompileExec2568490081.dir/build.make CMakeFiles/cmTryCompileExec2568490081.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2568490081.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDIO  -o CMakeFiles/cmTryCompileExec2568490081.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2568490081
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2568490081.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2568490081.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2568490081 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2724735435/fast"
make -f CMakeFiles/cmTryCompileExec2724735435.dir/build.make CMakeFiles/cmTryCompileExec2724735435.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2724735435.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_LFS_WORKS -DKWSYS_CXX_HAS_CSTDIO=1  -o CMakeFiles/cmTryCompileExec2724735435.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2724735435
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2724735435.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2724735435.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2724735435 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec454989365/fast"
make -f CMakeFiles/cmTryCompileExec454989365.dir/build.make CMakeFiles/cmTryCompileExec454989365.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec454989365.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAVE_STD  -o CMakeFiles/cmTryCompileExec454989365.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec454989365
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec454989365.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec454989365.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec454989365 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2614164940/fast"
make -f CMakeFiles/cmTryCompileExec2614164940.dir/build.make CMakeFiles/cmTryCompileExec2614164940.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2614164940.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_ANSI  -o CMakeFiles/cmTryCompileExec2614164940.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2614164940
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2614164940.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2614164940.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2614164940 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3716906284/fast"
make -f CMakeFiles/cmTryCompileExec3716906284.dir/build.make CMakeFiles/cmTryCompileExec3716906284.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3716906284.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_STD  -o CMakeFiles/cmTryCompileExec3716906284.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3716906284
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3716906284.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3716906284.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3716906284 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec383782650/fast"
make -f CMakeFiles/cmTryCompileExec383782650.dir/build.make CMakeFiles/cmTryCompileExec383782650.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec383782650.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_SSTREAM  -o CMakeFiles/cmTryCompileExec383782650.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec383782650
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec383782650.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec383782650.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec383782650 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1717672843/fast"
make -f CMakeFiles/cmTryCompileExec1717672843.dir/build.make CMakeFiles/cmTryCompileExec1717672843.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1717672843.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDDEF  -o CMakeFiles/cmTryCompileExec1717672843.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1717672843
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1717672843.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1717672843.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1717672843 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1553564297/fast"
make -f CMakeFiles/cmTryCompileExec1553564297.dir/build.make CMakeFiles/cmTryCompileExec1553564297.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1553564297.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec1553564297.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1553564297
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1553564297.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1553564297.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1553564297 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3319143533/fast"
make -f CMakeFiles/cmTryCompileExec3319143533.dir/build.make CMakeFiles/cmTryCompileExec3319143533.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3319143533.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec3319143533.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3319143533
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3319143533.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3319143533.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3319143533 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec587426387/fast"
make -f CMakeFiles/cmTryCompileExec587426387.dir/build.make CMakeFiles/cmTryCompileExec587426387.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec587426387.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec587426387.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec587426387
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec587426387.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec587426387.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec587426387 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec148349491/fast"
make -f CMakeFiles/cmTryCompileExec148349491.dir/build.make CMakeFiles/cmTryCompileExec148349491.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec148349491.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec148349491.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec148349491
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec148349491.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec148349491.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec148349491 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec941078384/fast"
make -f CMakeFiles/cmTryCompileExec941078384.dir/build.make CMakeFiles/cmTryCompileExec941078384.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec941078384.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec941078384.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec941078384
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec941078384.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec941078384.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec941078384 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2483470491/fast"
make -f CMakeFiles/cmTryCompileExec2483470491.dir/build.make CMakeFiles/cmTryCompileExec2483470491.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2483470491.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_BINARY -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec2483470491.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2483470491
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2483470491.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2483470491.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2483470491 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2895262016/fast"
make -f CMakeFiles/cmTryCompileExec2895262016.dir/build.make CMakeFiles/cmTryCompileExec2895262016.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2895262016.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES  -o CMakeFiles/cmTryCompileExec2895262016.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2895262016
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2895262016.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2895262016.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2895262016 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2652762809/fast"
make -f CMakeFiles/cmTryCompileExec2652762809.dir/build.make CMakeFiles/cmTryCompileExec2652762809.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2652762809.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION  -o CMakeFiles/cmTryCompileExec2652762809.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2652762809
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2652762809.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2652762809.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2652762809 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4188774807/fast"
make -f CMakeFiles/cmTryCompileExec4188774807.dir/build.make CMakeFiles/cmTryCompileExec4188774807.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4188774807.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP  -o CMakeFiles/cmTryCompileExec4188774807.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4188774807
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4188774807.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec4188774807.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4188774807 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3231167625/fast"
make -f CMakeFiles/cmTryCompileExec3231167625.dir/build.make CMakeFiles/cmTryCompileExec3231167625.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3231167625.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STAT_HAS_ST_MTIM  -o CMakeFiles/cmTryCompileExec3231167625.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3231167625
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3231167625.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3231167625.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3231167625 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4020758275/fast"
make -f CMakeFiles/cmTryCompileExec4020758275.dir/build.make CMakeFiles/cmTryCompileExec4020758275.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4020758275.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_TYPE_MACROS  -o CMakeFiles/cmTryCompileExec4020758275.dir/kwsysPlatformTestsC.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec4020758275
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4020758275.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec4020758275.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec4020758275 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3334842293/fast"
make -f CMakeFiles/cmTryCompileExec3334842293.dir/build.make CMakeFiles/cmTryCompileExec3334842293.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3334842293.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3334842293.dir/CheckIncludeFile.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3334842293
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3334842293.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3334842293.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3334842293 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4201534098/fast"
make -f CMakeFiles/cmTryCompileExec4201534098.dir/build.make CMakeFiles/cmTryCompileExec4201534098.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4201534098.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4201534098.dir/CheckIncludeFile.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec4201534098
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4201534098.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec4201534098.dir/CheckIncludeFile.c.o  -o cmTryCompileExec4201534098 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec306264838/fast"
make -f CMakeFiles/cmTryCompileExec306264838.dir/build.make CMakeFiles/cmTryCompileExec306264838.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec306264838.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec306264838.dir/CheckIncludeFile.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec306264838
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec306264838.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec306264838.dir/CheckIncludeFile.c.o  -o cmTryCompileExec306264838 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2105053144/fast"
make -f CMakeFiles/cmTryCompileExec2105053144.dir/build.make CMakeFiles/cmTryCompileExec2105053144.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2105053144.dir/KWSYS_SIZEOF_CHAR.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2105053144.dir/KWSYS_SIZEOF_CHAR.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec2105053144
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2105053144.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2105053144.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec2105053144 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3176711115/fast"
make -f CMakeFiles/cmTryCompileExec3176711115.dir/build.make CMakeFiles/cmTryCompileExec3176711115.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3176711115.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CHAR_IS_SIGNED  -o CMakeFiles/cmTryCompileExec3176711115.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3176711115
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3176711115.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec3176711115.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3176711115 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1675245843/fast"
make -f CMakeFiles/cmTryCompileExec1675245843.dir/build.make CMakeFiles/cmTryCompileExec1675245843.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1675245843.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_LONG_LONG  -o CMakeFiles/cmTryCompileExec1675245843.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1675245843
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1675245843.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec1675245843.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1675245843 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2336483896/fast"
make -f CMakeFiles/cmTryCompileExec2336483896.dir/build.make CMakeFiles/cmTryCompileExec2336483896.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2336483896.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec2336483896.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2336483896
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2336483896.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec2336483896.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2336483896 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec22563382/fast"
make -f CMakeFiles/cmTryCompileExec22563382.dir/build.make CMakeFiles/cmTryCompileExec22563382.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec22563382.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec22563382.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec22563382
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec22563382.dir/link.txt --verbose=1
/usr/bin/g++          CMakeFiles/cmTryCompileExec22563382.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec22563382 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec569161940/fast"
make -f CMakeFiles/cmTryCompileExec569161940.dir/build.make CMakeFiles/cmTryCompileExec569161940.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec569161940.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_PTRDIFF_T  -o CMakeFiles/cmTryCompileExec569161940.dir/kwsysPlatformTestsC.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec569161940
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec569161940.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec569161940.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec569161940 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3583362350/fast"
make -f CMakeFiles/cmTryCompileExec3583362350.dir/build.make CMakeFiles/cmTryCompileExec3583362350.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3583362350.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_SSIZE_T  -o CMakeFiles/cmTryCompileExec3583362350.dir/kwsysPlatformTestsC.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec3583362350
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3583362350.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec3583362350.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec3583362350 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3316761479/fast"
make -f CMakeFiles/cmTryCompileExec3316761479.dir/build.make CMakeFiles/cmTryCompileExec3316761479.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3316761479.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec3316761479.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3316761479
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3316761479.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=gethostbyname    CMakeFiles/cmTryCompileExec3316761479.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3316761479 -rdynamic -lc 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2636683527/fast"
make -f CMakeFiles/cmTryCompileExec2636683527.dir/build.make CMakeFiles/cmTryCompileExec2636683527.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2636683527.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec2636683527.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2636683527
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2636683527.dir/link.txt --verbose=1
/usr/bin/gcc      -DCHECK_FUNCTION_EXISTS=dlopen    CMakeFiles/cmTryCompileExec2636683527.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2636683527 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3606916103/fast"
make -f CMakeFiles/cmTryCompileExec3606916103.dir/build.make CMakeFiles/cmTryCompileExec3606916103.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3606916103.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3606916103.dir/CheckIncludeFile.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3606916103
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3606916103.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3606916103.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3606916103 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec235850368/fast"
make -f CMakeFiles/cmTryCompileExec235850368.dir/build.make CMakeFiles/cmTryCompileExec235850368.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec235850368.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec235850368.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec235850368
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec235850368.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec235850368.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec235850368 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec365680174/fast"
make -f CMakeFiles/cmTryCompileExec365680174.dir/build.make CMakeFiles/cmTryCompileExec365680174.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec365680174.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec365680174.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec365680174
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec365680174.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec365680174.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec365680174 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3394566214/fast"
make -f CMakeFiles/cmTryCompileExec3394566214.dir/build.make CMakeFiles/cmTryCompileExec3394566214.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3394566214.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3394566214.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3394566214
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3394566214.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3394566214.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3394566214 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2546490278/fast"
make -f CMakeFiles/cmTryCompileExec2546490278.dir/build.make CMakeFiles/cmTryCompileExec2546490278.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2546490278.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2546490278.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2546490278
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2546490278.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2546490278.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2546490278 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec99399298/fast"
make -f CMakeFiles/cmTryCompileExec99399298.dir/build.make CMakeFiles/cmTryCompileExec99399298.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec99399298.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec99399298.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec99399298
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec99399298.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec99399298.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec99399298 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3765444948/fast"
make -f CMakeFiles/cmTryCompileExec3765444948.dir/build.make CMakeFiles/cmTryCompileExec3765444948.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3765444948.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3765444948.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3765444948
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3765444948.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3765444948.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3765444948 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3700430432/fast"
make -f CMakeFiles/cmTryCompileExec3700430432.dir/build.make CMakeFiles/cmTryCompileExec3700430432.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3700430432.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3700430432.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3700430432
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3700430432.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3700430432.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3700430432 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1008737500/fast"
make -f CMakeFiles/cmTryCompileExec1008737500.dir/build.make CMakeFiles/cmTryCompileExec1008737500.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1008737500.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1008737500.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1008737500
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1008737500.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1008737500.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1008737500 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec729615767/fast"
make -f CMakeFiles/cmTryCompileExec729615767.dir/build.make CMakeFiles/cmTryCompileExec729615767.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec729615767.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec729615767.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec729615767
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec729615767.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec729615767.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec729615767 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2732313567/fast"
make -f CMakeFiles/cmTryCompileExec2732313567.dir/build.make CMakeFiles/cmTryCompileExec2732313567.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2732313567.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2732313567.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2732313567
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2732313567.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2732313567.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2732313567 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec549981822/fast"
make -f CMakeFiles/cmTryCompileExec549981822.dir/build.make CMakeFiles/cmTryCompileExec549981822.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec549981822.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec549981822.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec549981822
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec549981822.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec549981822.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec549981822 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1482249568/fast"
make -f CMakeFiles/cmTryCompileExec1482249568.dir/build.make CMakeFiles/cmTryCompileExec1482249568.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1482249568.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1482249568.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1482249568
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1482249568.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1482249568.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1482249568 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1569410088/fast"
make -f CMakeFiles/cmTryCompileExec1569410088.dir/build.make CMakeFiles/cmTryCompileExec1569410088.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1569410088.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1569410088.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1569410088
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1569410088.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1569410088.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1569410088 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4210599301/fast"
make -f CMakeFiles/cmTryCompileExec4210599301.dir/build.make CMakeFiles/cmTryCompileExec4210599301.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4210599301.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4210599301.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4210599301
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4210599301.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4210599301.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4210599301 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2007895303/fast"
make -f CMakeFiles/cmTryCompileExec2007895303.dir/build.make CMakeFiles/cmTryCompileExec2007895303.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2007895303.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2007895303.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2007895303
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2007895303.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2007895303.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2007895303 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4212762485/fast"
make -f CMakeFiles/cmTryCompileExec4212762485.dir/build.make CMakeFiles/cmTryCompileExec4212762485.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4212762485.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4212762485.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4212762485
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4212762485.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4212762485.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4212762485 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1534903076/fast"
make -f CMakeFiles/cmTryCompileExec1534903076.dir/build.make CMakeFiles/cmTryCompileExec1534903076.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1534903076.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1534903076.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1534903076
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1534903076.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1534903076.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1534903076 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec852071306/fast"
make -f CMakeFiles/cmTryCompileExec852071306.dir/build.make CMakeFiles/cmTryCompileExec852071306.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec852071306.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec852071306.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec852071306
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec852071306.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec852071306.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec852071306 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec875205244/fast"
make -f CMakeFiles/cmTryCompileExec875205244.dir/build.make CMakeFiles/cmTryCompileExec875205244.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec875205244.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec875205244.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec875205244
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec875205244.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec875205244.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec875205244 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1097993890/fast"
make -f CMakeFiles/cmTryCompileExec1097993890.dir/build.make CMakeFiles/cmTryCompileExec1097993890.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1097993890.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1097993890.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1097993890
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1097993890.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1097993890.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1097993890 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3310802415/fast"
make -f CMakeFiles/cmTryCompileExec3310802415.dir/build.make CMakeFiles/cmTryCompileExec3310802415.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3310802415.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3310802415.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3310802415
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3310802415.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3310802415.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3310802415 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec816848279/fast"
make -f CMakeFiles/cmTryCompileExec816848279.dir/build.make CMakeFiles/cmTryCompileExec816848279.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec816848279.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec816848279.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec816848279
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec816848279.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec816848279.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec816848279 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3193943414/fast"
make -f CMakeFiles/cmTryCompileExec3193943414.dir/build.make CMakeFiles/cmTryCompileExec3193943414.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3193943414.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3193943414.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3193943414
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3193943414.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3193943414.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3193943414 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1060859357/fast"
make -f CMakeFiles/cmTryCompileExec1060859357.dir/build.make CMakeFiles/cmTryCompileExec1060859357.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1060859357.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1060859357.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1060859357
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1060859357.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1060859357.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1060859357 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2180106790/fast"
make -f CMakeFiles/cmTryCompileExec2180106790.dir/build.make CMakeFiles/cmTryCompileExec2180106790.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2180106790.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2180106790.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2180106790
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2180106790.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2180106790.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2180106790 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec871674685/fast"
make -f CMakeFiles/cmTryCompileExec871674685.dir/build.make CMakeFiles/cmTryCompileExec871674685.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec871674685.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec871674685.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec871674685
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec871674685.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec871674685.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec871674685 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2273066001/fast"
make -f CMakeFiles/cmTryCompileExec2273066001.dir/build.make CMakeFiles/cmTryCompileExec2273066001.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2273066001.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2273066001.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2273066001
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2273066001.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2273066001.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2273066001 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec5351174/fast"
make -f CMakeFiles/cmTryCompileExec5351174.dir/build.make CMakeFiles/cmTryCompileExec5351174.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec5351174.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec5351174.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec5351174
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec5351174.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec5351174.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec5351174 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1264846340/fast"
make -f CMakeFiles/cmTryCompileExec1264846340.dir/build.make CMakeFiles/cmTryCompileExec1264846340.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1264846340.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1264846340.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1264846340
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1264846340.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1264846340.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1264846340 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3202688638/fast"
make -f CMakeFiles/cmTryCompileExec3202688638.dir/build.make CMakeFiles/cmTryCompileExec3202688638.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3202688638.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3202688638.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3202688638
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3202688638.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3202688638.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3202688638 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3616447991/fast"
make -f CMakeFiles/cmTryCompileExec3616447991.dir/build.make CMakeFiles/cmTryCompileExec3616447991.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3616447991.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3616447991.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3616447991
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3616447991.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3616447991.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3616447991 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2996812813/fast"
make -f CMakeFiles/cmTryCompileExec2996812813.dir/build.make CMakeFiles/cmTryCompileExec2996812813.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2996812813.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2996812813.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2996812813
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2996812813.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2996812813.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2996812813 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2220348368/fast"
make -f CMakeFiles/cmTryCompileExec2220348368.dir/build.make CMakeFiles/cmTryCompileExec2220348368.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2220348368.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2220348368.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2220348368
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2220348368.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2220348368.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2220348368 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec945469468/fast"
make -f CMakeFiles/cmTryCompileExec945469468.dir/build.make CMakeFiles/cmTryCompileExec945469468.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec945469468.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec945469468.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec945469468
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec945469468.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec945469468.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec945469468 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3449767192/fast"
make -f CMakeFiles/cmTryCompileExec3449767192.dir/build.make CMakeFiles/cmTryCompileExec3449767192.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3449767192.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3449767192.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3449767192
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3449767192.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3449767192.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3449767192 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3346946828/fast"
make -f CMakeFiles/cmTryCompileExec3346946828.dir/build.make CMakeFiles/cmTryCompileExec3346946828.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3346946828.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3346946828.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3346946828
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3346946828.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3346946828.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3346946828 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3646909500/fast"
make -f CMakeFiles/cmTryCompileExec3646909500.dir/build.make CMakeFiles/cmTryCompileExec3646909500.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3646909500.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3646909500.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3646909500
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3646909500.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3646909500.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3646909500 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2489951328/fast"
make -f CMakeFiles/cmTryCompileExec2489951328.dir/build.make CMakeFiles/cmTryCompileExec2489951328.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2489951328.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2489951328.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2489951328
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2489951328.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2489951328.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2489951328 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3846760758/fast"
make -f CMakeFiles/cmTryCompileExec3846760758.dir/build.make CMakeFiles/cmTryCompileExec3846760758.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3846760758.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3846760758.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3846760758
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3846760758.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3846760758.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3846760758 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec853203329/fast"
make -f CMakeFiles/cmTryCompileExec853203329.dir/build.make CMakeFiles/cmTryCompileExec853203329.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec853203329.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec853203329.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec853203329
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec853203329.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec853203329.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec853203329 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3674696757/fast"
make -f CMakeFiles/cmTryCompileExec3674696757.dir/build.make CMakeFiles/cmTryCompileExec3674696757.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3674696757.dir/SIZEOF_SIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3674696757.dir/SIZEOF_SIZE_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec3674696757
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3674696757.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3674696757.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec3674696757 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec294296738/fast"
make -f CMakeFiles/cmTryCompileExec294296738.dir/build.make CMakeFiles/cmTryCompileExec294296738.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec294296738.dir/SIZEOF_SSIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec294296738.dir/SIZEOF_SSIZE_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec294296738
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec294296738.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec294296738.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec294296738 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3507372818/fast"
make -f CMakeFiles/cmTryCompileExec3507372818.dir/build.make CMakeFiles/cmTryCompileExec3507372818.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3507372818.dir/SIZEOF_LONG_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3507372818.dir/SIZEOF_LONG_LONG.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec3507372818
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3507372818.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3507372818.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec3507372818 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1637812537/fast"
make -f CMakeFiles/cmTryCompileExec1637812537.dir/build.make CMakeFiles/cmTryCompileExec1637812537.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1637812537.dir/SIZEOF_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1637812537.dir/SIZEOF_LONG.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec1637812537
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1637812537.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1637812537.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec1637812537 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1470898059/fast"
make -f CMakeFiles/cmTryCompileExec1470898059.dir/build.make CMakeFiles/cmTryCompileExec1470898059.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1470898059.dir/SIZEOF_TIME_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1470898059.dir/SIZEOF_TIME_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec1470898059
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1470898059.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1470898059.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec1470898059 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3763770062/fast"
make -f CMakeFiles/cmTryCompileExec3763770062.dir/build.make CMakeFiles/cmTryCompileExec3763770062.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3763770062.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3763770062.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3763770062
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3763770062.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3763770062.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3763770062 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4132954910/fast"
make -f CMakeFiles/cmTryCompileExec4132954910.dir/build.make CMakeFiles/cmTryCompileExec4132954910.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4132954910.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4132954910.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4132954910
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4132954910.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4132954910.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4132954910 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3989830771/fast"
make -f CMakeFiles/cmTryCompileExec3989830771.dir/build.make CMakeFiles/cmTryCompileExec3989830771.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3989830771.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3989830771.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3989830771
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3989830771.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3989830771.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3989830771 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1266369002/fast"
make -f CMakeFiles/cmTryCompileExec1266369002.dir/build.make CMakeFiles/cmTryCompileExec1266369002.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1266369002.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1266369002.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1266369002
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1266369002.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1266369002.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1266369002 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2359448756/fast"
make -f CMakeFiles/cmTryCompileExec2359448756.dir/build.make CMakeFiles/cmTryCompileExec2359448756.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2359448756.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2359448756.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2359448756
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2359448756.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2359448756.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2359448756 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3880194341/fast"
make -f CMakeFiles/cmTryCompileExec3880194341.dir/build.make CMakeFiles/cmTryCompileExec3880194341.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3880194341.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3880194341.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3880194341
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3880194341.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3880194341.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3880194341 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2815724525/fast"
make -f CMakeFiles/cmTryCompileExec2815724525.dir/build.make CMakeFiles/cmTryCompileExec2815724525.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2815724525.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2815724525.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2815724525
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2815724525.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2815724525.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2815724525 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec330268048/fast"
make -f CMakeFiles/cmTryCompileExec330268048.dir/build.make CMakeFiles/cmTryCompileExec330268048.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec330268048.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec330268048.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec330268048
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec330268048.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec330268048.dir/CheckSymbolExists.c.o  -o cmTryCompileExec330268048 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2008262235/fast"
make -f CMakeFiles/cmTryCompileExec2008262235.dir/build.make CMakeFiles/cmTryCompileExec2008262235.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2008262235.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2008262235.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2008262235
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2008262235.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2008262235.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2008262235 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2887766358/fast"
make -f CMakeFiles/cmTryCompileExec2887766358.dir/build.make CMakeFiles/cmTryCompileExec2887766358.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2887766358.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2887766358.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2887766358
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2887766358.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2887766358.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2887766358 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2036172147/fast"
make -f CMakeFiles/cmTryCompileExec2036172147.dir/build.make CMakeFiles/cmTryCompileExec2036172147.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2036172147.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2036172147.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2036172147
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2036172147.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2036172147.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2036172147 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2222577044/fast"
make -f CMakeFiles/cmTryCompileExec2222577044.dir/build.make CMakeFiles/cmTryCompileExec2222577044.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2222577044.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2222577044.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2222577044
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2222577044.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2222577044.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2222577044 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3207451607/fast"
make -f CMakeFiles/cmTryCompileExec3207451607.dir/build.make CMakeFiles/cmTryCompileExec3207451607.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3207451607.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3207451607.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3207451607
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3207451607.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3207451607.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3207451607 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2637902587/fast"
make -f CMakeFiles/cmTryCompileExec2637902587.dir/build.make CMakeFiles/cmTryCompileExec2637902587.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2637902587.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2637902587.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2637902587
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2637902587.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2637902587.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2637902587 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2839015559/fast"
make -f CMakeFiles/cmTryCompileExec2839015559.dir/build.make CMakeFiles/cmTryCompileExec2839015559.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2839015559.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2839015559.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2839015559
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2839015559.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2839015559.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2839015559 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3563624020/fast"
make -f CMakeFiles/cmTryCompileExec3563624020.dir/build.make CMakeFiles/cmTryCompileExec3563624020.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3563624020.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3563624020.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3563624020
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3563624020.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3563624020.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3563624020 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2776382509/fast"
make -f CMakeFiles/cmTryCompileExec2776382509.dir/build.make CMakeFiles/cmTryCompileExec2776382509.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2776382509.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2776382509.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2776382509
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2776382509.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2776382509.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2776382509 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1942931172/fast"
make -f CMakeFiles/cmTryCompileExec1942931172.dir/build.make CMakeFiles/cmTryCompileExec1942931172.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1942931172.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1942931172.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1942931172
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1942931172.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1942931172.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1942931172 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1904548690/fast"
make -f CMakeFiles/cmTryCompileExec1904548690.dir/build.make CMakeFiles/cmTryCompileExec1904548690.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1904548690.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1904548690.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1904548690
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1904548690.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1904548690.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1904548690 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4129545402/fast"
make -f CMakeFiles/cmTryCompileExec4129545402.dir/build.make CMakeFiles/cmTryCompileExec4129545402.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4129545402.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4129545402.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4129545402
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4129545402.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4129545402.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4129545402 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2719633120/fast"
make -f CMakeFiles/cmTryCompileExec2719633120.dir/build.make CMakeFiles/cmTryCompileExec2719633120.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2719633120.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2719633120.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2719633120
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2719633120.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2719633120.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2719633120 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1989207488/fast"
make -f CMakeFiles/cmTryCompileExec1989207488.dir/build.make CMakeFiles/cmTryCompileExec1989207488.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1989207488.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1989207488.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1989207488
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1989207488.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1989207488.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1989207488 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1738325796/fast"
make -f CMakeFiles/cmTryCompileExec1738325796.dir/build.make CMakeFiles/cmTryCompileExec1738325796.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1738325796.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1738325796.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1738325796
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1738325796.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1738325796.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1738325796 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec541701562/fast"
make -f CMakeFiles/cmTryCompileExec541701562.dir/build.make CMakeFiles/cmTryCompileExec541701562.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec541701562.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec541701562.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec541701562
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec541701562.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec541701562.dir/CheckSymbolExists.c.o  -o cmTryCompileExec541701562 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3828746819/fast"
make -f CMakeFiles/cmTryCompileExec3828746819.dir/build.make CMakeFiles/cmTryCompileExec3828746819.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3828746819.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3828746819.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3828746819
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3828746819.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3828746819.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3828746819 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3135048371/fast"
make -f CMakeFiles/cmTryCompileExec3135048371.dir/build.make CMakeFiles/cmTryCompileExec3135048371.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3135048371.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3135048371.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3135048371
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3135048371.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3135048371.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3135048371 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3257722974/fast"
make -f CMakeFiles/cmTryCompileExec3257722974.dir/build.make CMakeFiles/cmTryCompileExec3257722974.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3257722974.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3257722974.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3257722974
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3257722974.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3257722974.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3257722974 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2958691729/fast"
make -f CMakeFiles/cmTryCompileExec2958691729.dir/build.make CMakeFiles/cmTryCompileExec2958691729.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2958691729.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2958691729.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2958691729
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2958691729.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2958691729.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2958691729 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec45752898/fast"
make -f CMakeFiles/cmTryCompileExec45752898.dir/build.make CMakeFiles/cmTryCompileExec45752898.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec45752898.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec45752898.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec45752898
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec45752898.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec45752898.dir/CheckSymbolExists.c.o  -o cmTryCompileExec45752898 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec282904724/fast"
make -f CMakeFiles/cmTryCompileExec282904724.dir/build.make CMakeFiles/cmTryCompileExec282904724.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec282904724.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec282904724.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec282904724
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec282904724.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec282904724.dir/CheckSymbolExists.c.o  -o cmTryCompileExec282904724 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1506793251/fast"
make -f CMakeFiles/cmTryCompileExec1506793251.dir/build.make CMakeFiles/cmTryCompileExec1506793251.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1506793251.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1506793251.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1506793251
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1506793251.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1506793251.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1506793251 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1599541351/fast"
make -f CMakeFiles/cmTryCompileExec1599541351.dir/build.make CMakeFiles/cmTryCompileExec1599541351.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1599541351.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1599541351.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1599541351
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1599541351.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1599541351.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1599541351 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3110374499/fast"
make -f CMakeFiles/cmTryCompileExec3110374499.dir/build.make CMakeFiles/cmTryCompileExec3110374499.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3110374499.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3110374499.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3110374499
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3110374499.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3110374499.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3110374499 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec284402110/fast"
make -f CMakeFiles/cmTryCompileExec284402110.dir/build.make CMakeFiles/cmTryCompileExec284402110.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec284402110.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec284402110.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec284402110
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec284402110.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec284402110.dir/CheckSymbolExists.c.o  -o cmTryCompileExec284402110 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec187643363/fast"
make -f CMakeFiles/cmTryCompileExec187643363.dir/build.make CMakeFiles/cmTryCompileExec187643363.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec187643363.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec187643363.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec187643363
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec187643363.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec187643363.dir/CheckSymbolExists.c.o  -o cmTryCompileExec187643363 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3192522064/fast"
make -f CMakeFiles/cmTryCompileExec3192522064.dir/build.make CMakeFiles/cmTryCompileExec3192522064.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3192522064.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3192522064.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3192522064
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3192522064.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3192522064.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3192522064 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1783409214/fast"
make -f CMakeFiles/cmTryCompileExec1783409214.dir/build.make CMakeFiles/cmTryCompileExec1783409214.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1783409214.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1783409214.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1783409214
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1783409214.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec1783409214.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1783409214 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2288822986/fast"
make -f CMakeFiles/cmTryCompileExec2288822986.dir/build.make CMakeFiles/cmTryCompileExec2288822986.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2288822986.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2288822986.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2288822986
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2288822986.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec2288822986.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2288822986 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec892701367/fast"
make -f CMakeFiles/cmTryCompileExec892701367.dir/build.make CMakeFiles/cmTryCompileExec892701367.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec892701367.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec892701367.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec892701367
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec892701367.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec892701367.dir/CheckSymbolExists.c.o  -o cmTryCompileExec892701367 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec469765378/fast"
make -f CMakeFiles/cmTryCompileExec469765378.dir/build.make CMakeFiles/cmTryCompileExec469765378.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec469765378.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec469765378.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec469765378
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec469765378.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec469765378.dir/CheckSymbolExists.c.o  -o cmTryCompileExec469765378 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4035475301/fast"
make -f CMakeFiles/cmTryCompileExec4035475301.dir/build.make CMakeFiles/cmTryCompileExec4035475301.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4035475301.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4035475301.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4035475301
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4035475301.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec4035475301.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4035475301 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3556047025/fast"
make -f CMakeFiles/cmTryCompileExec3556047025.dir/build.make CMakeFiles/cmTryCompileExec3556047025.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3556047025.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec3556047025.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3556047025
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3556047025.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_O_NONBLOCK    CMakeFiles/cmTryCompileExec3556047025.dir/CurlTests.c.o  -o cmTryCompileExec3556047025 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec583696080/fast"
make -f CMakeFiles/cmTryCompileExec583696080.dir/build.make CMakeFiles/cmTryCompileExec583696080.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec583696080.dir/CurlTests.c.o
/usr/bin/gcc   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec583696080.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec583696080
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec583696080.dir/link.txt --verbose=1
/usr/bin/gcc      -DTIME_WITH_SYS_TIME    CMakeFiles/cmTryCompileExec583696080.dir/CurlTests.c.o  -o cmTryCompileExec583696080 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2972359676/fast"
make -f CMakeFiles/cmTryCompileExec2972359676.dir/build.make CMakeFiles/cmTryCompileExec2972359676.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2972359676.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec2972359676.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2972359676
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2972359676.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8    CMakeFiles/cmTryCompileExec2972359676.dir/CurlTests.c.o  -o cmTryCompileExec2972359676 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1204538529/fast"
make -f CMakeFiles/cmTryCompileExec1204538529.dir/build.make CMakeFiles/cmTryCompileExec1204538529.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1204538529.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec1204538529.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1204538529
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1204538529.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYADDR_R_8_REENTRANT    CMakeFiles/cmTryCompileExec1204538529.dir/CurlTests.c.o  -o cmTryCompileExec1204538529 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1873610637/fast"
make -f CMakeFiles/cmTryCompileExec1873610637.dir/build.make CMakeFiles/cmTryCompileExec1873610637.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1873610637.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec1873610637.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1873610637
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1873610637.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6    CMakeFiles/cmTryCompileExec1873610637.dir/CurlTests.c.o  -o cmTryCompileExec1873610637 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec7513330/fast"
make -f CMakeFiles/cmTryCompileExec7513330.dir/build.make CMakeFiles/cmTryCompileExec7513330.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec7513330.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec7513330.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec7513330
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec7513330.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETHOSTBYNAME_R_6_REENTRANT    CMakeFiles/cmTryCompileExec7513330.dir/CurlTests.c.o  -o cmTryCompileExec7513330 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1092537665/fast"
make -f CMakeFiles/cmTryCompileExec1092537665.dir/build.make CMakeFiles/cmTryCompileExec1092537665.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1092537665.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec1092537665.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1092537665
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1092537665.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SOCKLEN_T    CMakeFiles/cmTryCompileExec1092537665.dir/CurlTests.c.o  -o cmTryCompileExec1092537665 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4180042933/fast"
make -f CMakeFiles/cmTryCompileExec4180042933.dir/build.make CMakeFiles/cmTryCompileExec4180042933.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4180042933.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec4180042933.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec4180042933
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4180042933.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_IN_ADDR_T    CMakeFiles/cmTryCompileExec4180042933.dir/CurlTests.c.o  -o cmTryCompileExec4180042933 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4185602767/fast"
make -f CMakeFiles/cmTryCompileExec4185602767.dir/build.make CMakeFiles/cmTryCompileExec4185602767.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4185602767.dir/CurlTests.c.o
/usr/bin/gcc   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec4185602767.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec4185602767
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4185602767.dir/link.txt --verbose=1
/usr/bin/gcc      -DSTDC_HEADERS    CMakeFiles/cmTryCompileExec4185602767.dir/CurlTests.c.o  -o cmTryCompileExec4185602767 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec841093557/fast"
make -f CMakeFiles/cmTryCompileExec841093557.dir/build.make CMakeFiles/cmTryCompileExec841093557.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec841093557.dir/CurlTests.c.o
/usr/bin/gcc   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec841093557.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec841093557
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec841093557.dir/link.txt --verbose=1
/usr/bin/gcc      -DRETSIGTYPE_TEST    CMakeFiles/cmTryCompileExec841093557.dir/CurlTests.c.o  -o cmTryCompileExec841093557 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1780087608/fast"
make -f CMakeFiles/cmTryCompileExec1780087608.dir/build.make CMakeFiles/cmTryCompileExec1780087608.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1780087608.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec1780087608.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c:405: warning: incompatible implicit declaration of built-in function ‘memset’
Linking C executable cmTryCompileExec1780087608
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1780087608.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_GETADDRINFO    CMakeFiles/cmTryCompileExec1780087608.dir/CurlTests.c.o  -o cmTryCompileExec1780087608 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec458331225/fast"
make -f CMakeFiles/cmTryCompileExec458331225.dir/build.make CMakeFiles/cmTryCompileExec458331225.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec458331225.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec458331225.dir/CurlTests.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec458331225
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec458331225.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_FILE_OFFSET_BITS    CMakeFiles/cmTryCompileExec458331225.dir/CurlTests.c.o  -o cmTryCompileExec458331225 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3440360168/fast"
make -f CMakeFiles/cmTryCompileExec3440360168.dir/build.make CMakeFiles/cmTryCompileExec3440360168.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3440360168.dir/SIZEOF_CURL_OFF_T.c.o
/usr/bin/gcc   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec3440360168.dir/SIZEOF_CURL_OFF_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec3440360168
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3440360168.dir/link.txt --verbose=1
/usr/bin/gcc      -D_FILE_OFFSET_BITS=64    CMakeFiles/cmTryCompileExec3440360168.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec3440360168 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4252015929/fast"
make -f CMakeFiles/cmTryCompileExec4252015929.dir/build.make CMakeFiles/cmTryCompileExec4252015929.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4252015929.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec4252015929.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4252015929
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4252015929.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_recv    CMakeFiles/cmTryCompileExec4252015929.dir/src.c.o  -o cmTryCompileExec4252015929 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1823913129/fast"
make -f CMakeFiles/cmTryCompileExec1823913129.dir/build.make CMakeFiles/cmTryCompileExec1823913129.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1823913129.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec1823913129.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1823913129
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1823913129.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_recv_test    CMakeFiles/cmTryCompileExec1823913129.dir/src.c.o  -o cmTryCompileExec1823913129 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2409045808/fast"
make -f CMakeFiles/cmTryCompileExec2409045808.dir/build.make CMakeFiles/cmTryCompileExec2409045808.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2409045808.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec2409045808.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2409045808
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2409045808.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_send    CMakeFiles/cmTryCompileExec2409045808.dir/src.c.o  -o cmTryCompileExec2409045808 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec280613548/fast"
make -f CMakeFiles/cmTryCompileExec280613548.dir/build.make CMakeFiles/cmTryCompileExec280613548.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec280613548.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec280613548.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec280613548
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec280613548.dir/link.txt --verbose=1
/usr/bin/gcc      -Dcurl_cv_func_send_test    CMakeFiles/cmTryCompileExec280613548.dir/src.c.o  -o cmTryCompileExec280613548 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec262906209/fast"
make -f CMakeFiles/cmTryCompileExec262906209.dir/build.make CMakeFiles/cmTryCompileExec262906209.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec262906209.dir/src.c.o
/usr/bin/gcc   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec262906209.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c:12:1: warning: "__unused5" redefined
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c:8:1: warning: this is the location of the previous definition
Linking C executable cmTryCompileExec262906209
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec262906209.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_MSG_NOSIGNAL    CMakeFiles/cmTryCompileExec262906209.dir/src.c.o  -o cmTryCompileExec262906209 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2802225873/fast"
make -f CMakeFiles/cmTryCompileExec2802225873.dir/build.make CMakeFiles/cmTryCompileExec2802225873.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2802225873.dir/src.c.o
/usr/bin/gcc   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec2802225873.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2802225873
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2802225873.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_STRUCT_TIMEVAL    CMakeFiles/cmTryCompileExec2802225873.dir/src.c.o  -o cmTryCompileExec2802225873 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3808044344/fast"
make -f CMakeFiles/cmTryCompileExec3808044344.dir/build.make CMakeFiles/cmTryCompileExec3808044344.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3808044344.dir/SIZEOF_SIG_ATOMIC_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3808044344.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec3808044344
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3808044344.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3808044344.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec3808044344 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4135243361/fast"
make -f CMakeFiles/cmTryCompileExec4135243361.dir/build.make CMakeFiles/cmTryCompileExec4135243361.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4135243361.dir/src.c.o
/usr/bin/gcc   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec4135243361.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4135243361
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4135243361.dir/link.txt --verbose=1
/usr/bin/gcc      -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE    CMakeFiles/cmTryCompileExec4135243361.dir/src.c.o  -o cmTryCompileExec4135243361 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3645138261/fast"
make -f CMakeFiles/cmTryCompileExec3645138261.dir/build.make CMakeFiles/cmTryCompileExec3645138261.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3645138261.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3645138261.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec3645138261
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3645138261.dir/link.txt --verbose=1
/usr/bin/gcc          CMakeFiles/cmTryCompileExec3645138261.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec3645138261 -rdynamic -ldl 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3284764498/fast"
make -f CMakeFiles/cmTryCompileExec3284764498.dir/build.make CMakeFiles/cmTryCompileExec3284764498.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3284764498.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec3284764498.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3284764498
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3284764498.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_DIRENT_H    CMakeFiles/cmTryCompileExec3284764498.dir/src.c.o  -o cmTryCompileExec3284764498 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1464021052/fast"
make -f CMakeFiles/cmTryCompileExec1464021052.dir/build.make CMakeFiles/cmTryCompileExec1464021052.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1464021052.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1464021052.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1464021052
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1464021052.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1464021052.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1464021052 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1067154274/fast"
make -f CMakeFiles/cmTryCompileExec1067154274.dir/build.make CMakeFiles/cmTryCompileExec1067154274.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1067154274.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1067154274.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1067154274
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1067154274.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1067154274.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1067154274 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2453624841/fast"
make -f CMakeFiles/cmTryCompileExec2453624841.dir/build.make CMakeFiles/cmTryCompileExec2453624841.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2453624841.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2453624841.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2453624841
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2453624841.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2453624841.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2453624841 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec731468386/fast"
make -f CMakeFiles/cmTryCompileExec731468386.dir/build.make CMakeFiles/cmTryCompileExec731468386.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec731468386.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec731468386.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec731468386
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec731468386.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec731468386.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec731468386 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec181512146/fast"
make -f CMakeFiles/cmTryCompileExec181512146.dir/build.make CMakeFiles/cmTryCompileExec181512146.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec181512146.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec181512146.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec181512146
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec181512146.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec181512146.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec181512146 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1982349031/fast"
make -f CMakeFiles/cmTryCompileExec1982349031.dir/build.make CMakeFiles/cmTryCompileExec1982349031.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1982349031.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1982349031.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1982349031
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1982349031.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1982349031.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1982349031 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec455146549/fast"
make -f CMakeFiles/cmTryCompileExec455146549.dir/build.make CMakeFiles/cmTryCompileExec455146549.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec455146549.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec455146549.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec455146549
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec455146549.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec455146549.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec455146549 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3986387517/fast"
make -f CMakeFiles/cmTryCompileExec3986387517.dir/build.make CMakeFiles/cmTryCompileExec3986387517.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3986387517.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3986387517.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3986387517
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3986387517.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3986387517.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3986387517 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec904243782/fast"
make -f CMakeFiles/cmTryCompileExec904243782.dir/build.make CMakeFiles/cmTryCompileExec904243782.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec904243782.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec904243782.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec904243782
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec904243782.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec904243782.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec904243782 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3014864557/fast"
make -f CMakeFiles/cmTryCompileExec3014864557.dir/build.make CMakeFiles/cmTryCompileExec3014864557.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3014864557.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3014864557.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3014864557
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3014864557.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3014864557.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3014864557 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec765834336/fast"
make -f CMakeFiles/cmTryCompileExec765834336.dir/build.make CMakeFiles/cmTryCompileExec765834336.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec765834336.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec765834336.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec765834336
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec765834336.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec765834336.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec765834336 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec649331161/fast"
make -f CMakeFiles/cmTryCompileExec649331161.dir/build.make CMakeFiles/cmTryCompileExec649331161.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec649331161.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec649331161.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec649331161
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec649331161.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec649331161.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec649331161 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3666861099/fast"
make -f CMakeFiles/cmTryCompileExec3666861099.dir/build.make CMakeFiles/cmTryCompileExec3666861099.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3666861099.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3666861099.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3666861099
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3666861099.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3666861099.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3666861099 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2907046340/fast"
make -f CMakeFiles/cmTryCompileExec2907046340.dir/build.make CMakeFiles/cmTryCompileExec2907046340.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2907046340.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2907046340.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2907046340
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2907046340.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2907046340.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2907046340 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3376873599/fast"
make -f CMakeFiles/cmTryCompileExec3376873599.dir/build.make CMakeFiles/cmTryCompileExec3376873599.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3376873599.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3376873599.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3376873599
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3376873599.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3376873599.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3376873599 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4112143812/fast"
make -f CMakeFiles/cmTryCompileExec4112143812.dir/build.make CMakeFiles/cmTryCompileExec4112143812.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4112143812.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4112143812.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4112143812
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4112143812.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4112143812.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4112143812 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec413868312/fast"
make -f CMakeFiles/cmTryCompileExec413868312.dir/build.make CMakeFiles/cmTryCompileExec413868312.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec413868312.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec413868312.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec413868312
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec413868312.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec413868312.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec413868312 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2513034052/fast"
make -f CMakeFiles/cmTryCompileExec2513034052.dir/build.make CMakeFiles/cmTryCompileExec2513034052.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2513034052.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2513034052.dir/CheckIncludeFiles.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2513034052
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2513034052.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2513034052.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2513034052 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec222867472/fast"
make -f CMakeFiles/cmTryCompileExec222867472.dir/build.make CMakeFiles/cmTryCompileExec222867472.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec222867472.dir/src.c.o
/usr/bin/gcc   -w  -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec222867472.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec222867472
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec222867472.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DSAFE_TO_DEFINE_EXTENSIONS    CMakeFiles/cmTryCompileExec222867472.dir/src.c.o  -o cmTryCompileExec222867472 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec321946268/fast"
make -f CMakeFiles/cmTryCompileExec321946268.dir/build.make CMakeFiles/cmTryCompileExec321946268.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec321946268.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -o CMakeFiles/cmTryCompileExec321946268.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec321946268
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec321946268.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin    CMakeFiles/cmTryCompileExec321946268.dir/CheckFunctionExists.c.o  -o cmTryCompileExec321946268 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1490481542/fast"
make -f CMakeFiles/cmTryCompileExec1490481542.dir/build.make CMakeFiles/cmTryCompileExec1490481542.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1490481542.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -o CMakeFiles/cmTryCompileExec1490481542.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1490481542
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1490481542.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin    CMakeFiles/cmTryCompileExec1490481542.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1490481542 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec239447101/fast"
make -f CMakeFiles/cmTryCompileExec239447101.dir/build.make CMakeFiles/cmTryCompileExec239447101.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec239447101.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec239447101.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec239447101
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec239447101.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin    CMakeFiles/cmTryCompileExec239447101.dir/CheckFunctionExists.c.o  -o cmTryCompileExec239447101 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2295682463/fast"
make -f CMakeFiles/cmTryCompileExec2295682463.dir/build.make CMakeFiles/cmTryCompileExec2295682463.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2295682463.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec2295682463.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2295682463
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2295682463.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin    CMakeFiles/cmTryCompileExec2295682463.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2295682463 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3660131476/fast"
make -f CMakeFiles/cmTryCompileExec3660131476.dir/build.make CMakeFiles/cmTryCompileExec3660131476.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3660131476.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -o CMakeFiles/cmTryCompileExec3660131476.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3660131476
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3660131476.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin    CMakeFiles/cmTryCompileExec3660131476.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3660131476 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3163210081/fast"
make -f CMakeFiles/cmTryCompileExec3163210081.dir/build.make CMakeFiles/cmTryCompileExec3163210081.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3163210081.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec3163210081.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3163210081
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3163210081.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin    CMakeFiles/cmTryCompileExec3163210081.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3163210081 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2900188803/fast"
make -f CMakeFiles/cmTryCompileExec2900188803.dir/build.make CMakeFiles/cmTryCompileExec2900188803.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2900188803.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -o CMakeFiles/cmTryCompileExec2900188803.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2900188803
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2900188803.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin    CMakeFiles/cmTryCompileExec2900188803.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2900188803 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3324270225/fast"
make -f CMakeFiles/cmTryCompileExec3324270225.dir/build.make CMakeFiles/cmTryCompileExec3324270225.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3324270225.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -o CMakeFiles/cmTryCompileExec3324270225.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3324270225
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3324270225.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin    CMakeFiles/cmTryCompileExec3324270225.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3324270225 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2188595990/fast"
make -f CMakeFiles/cmTryCompileExec2188595990.dir/build.make CMakeFiles/cmTryCompileExec2188595990.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2188595990.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2188595990.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2188595990
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2188595990.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin    CMakeFiles/cmTryCompileExec2188595990.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2188595990 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec781785972/fast"
make -f CMakeFiles/cmTryCompileExec781785972.dir/build.make CMakeFiles/cmTryCompileExec781785972.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec781785972.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -o CMakeFiles/cmTryCompileExec781785972.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec781785972
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec781785972.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin    CMakeFiles/cmTryCompileExec781785972.dir/CheckFunctionExists.c.o  -o cmTryCompileExec781785972 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec485461704/fast"
make -f CMakeFiles/cmTryCompileExec485461704.dir/build.make CMakeFiles/cmTryCompileExec485461704.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec485461704.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec485461704.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec485461704
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec485461704.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin    CMakeFiles/cmTryCompileExec485461704.dir/CheckFunctionExists.c.o  -o cmTryCompileExec485461704 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3581313645/fast"
make -f CMakeFiles/cmTryCompileExec3581313645.dir/build.make CMakeFiles/cmTryCompileExec3581313645.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3581313645.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3581313645.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3581313645
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3581313645.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin    CMakeFiles/cmTryCompileExec3581313645.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3581313645 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2196166014/fast"
make -f CMakeFiles/cmTryCompileExec2196166014.dir/build.make CMakeFiles/cmTryCompileExec2196166014.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2196166014.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -o CMakeFiles/cmTryCompileExec2196166014.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2196166014
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2196166014.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin    CMakeFiles/cmTryCompileExec2196166014.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2196166014 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec501791744/fast"
make -f CMakeFiles/cmTryCompileExec501791744.dir/build.make CMakeFiles/cmTryCompileExec501791744.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec501791744.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec501791744.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec501791744
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec501791744.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin    CMakeFiles/cmTryCompileExec501791744.dir/CheckFunctionExists.c.o  -o cmTryCompileExec501791744 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3787230187/fast"
make -f CMakeFiles/cmTryCompileExec3787230187.dir/build.make CMakeFiles/cmTryCompileExec3787230187.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3787230187.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3787230187.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3787230187
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3787230187.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin    CMakeFiles/cmTryCompileExec3787230187.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3787230187 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1803478604/fast"
make -f CMakeFiles/cmTryCompileExec1803478604.dir/build.make CMakeFiles/cmTryCompileExec1803478604.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1803478604.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec1803478604.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1803478604
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1803478604.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin    CMakeFiles/cmTryCompileExec1803478604.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1803478604 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2857259580/fast"
make -f CMakeFiles/cmTryCompileExec2857259580.dir/build.make CMakeFiles/cmTryCompileExec2857259580.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2857259580.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2857259580.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2857259580
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2857259580.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec2857259580.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2857259580 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2407947539/fast"
make -f CMakeFiles/cmTryCompileExec2407947539.dir/build.make CMakeFiles/cmTryCompileExec2407947539.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2407947539.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2407947539.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2407947539
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2407947539.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec2407947539.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2407947539 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3863001369/fast"
make -f CMakeFiles/cmTryCompileExec3863001369.dir/build.make CMakeFiles/cmTryCompileExec3863001369.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3863001369.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3863001369.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3863001369
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3863001369.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin    CMakeFiles/cmTryCompileExec3863001369.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3863001369 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3493914450/fast"
make -f CMakeFiles/cmTryCompileExec3493914450.dir/build.make CMakeFiles/cmTryCompileExec3493914450.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3493914450.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -o CMakeFiles/cmTryCompileExec3493914450.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3493914450
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3493914450.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin    CMakeFiles/cmTryCompileExec3493914450.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3493914450 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2261660150/fast"
make -f CMakeFiles/cmTryCompileExec2261660150.dir/build.make CMakeFiles/cmTryCompileExec2261660150.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2261660150.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec2261660150.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2261660150
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2261660150.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin    CMakeFiles/cmTryCompileExec2261660150.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2261660150 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3247255324/fast"
make -f CMakeFiles/cmTryCompileExec3247255324.dir/build.make CMakeFiles/cmTryCompileExec3247255324.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3247255324.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -o CMakeFiles/cmTryCompileExec3247255324.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3247255324
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3247255324.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin    CMakeFiles/cmTryCompileExec3247255324.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3247255324 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec989005654/fast"
make -f CMakeFiles/cmTryCompileExec989005654.dir/build.make CMakeFiles/cmTryCompileExec989005654.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec989005654.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec989005654.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec989005654
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec989005654.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin    CMakeFiles/cmTryCompileExec989005654.dir/CheckFunctionExists.c.o  -o cmTryCompileExec989005654 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec578452325/fast"
make -f CMakeFiles/cmTryCompileExec578452325.dir/build.make CMakeFiles/cmTryCompileExec578452325.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec578452325.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec578452325.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec578452325
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec578452325.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin    CMakeFiles/cmTryCompileExec578452325.dir/CheckFunctionExists.c.o  -o cmTryCompileExec578452325 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3220582665/fast"
make -f CMakeFiles/cmTryCompileExec3220582665.dir/build.make CMakeFiles/cmTryCompileExec3220582665.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3220582665.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -o CMakeFiles/cmTryCompileExec3220582665.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3220582665
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3220582665.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin    CMakeFiles/cmTryCompileExec3220582665.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3220582665 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function mbsnrtowcs exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1503844165/fast"
make -f CMakeFiles/cmTryCompileExec1503844165.dir/build.make CMakeFiles/cmTryCompileExec1503844165.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1503844165.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1503844165.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1503844165
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1503844165.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin    CMakeFiles/cmTryCompileExec1503844165.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1503844165 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2650463254/fast"
make -f CMakeFiles/cmTryCompileExec2650463254.dir/build.make CMakeFiles/cmTryCompileExec2650463254.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2650463254.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -o CMakeFiles/cmTryCompileExec2650463254.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2650463254
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2650463254.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin    CMakeFiles/cmTryCompileExec2650463254.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2650463254 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec222814853/fast"
make -f CMakeFiles/cmTryCompileExec222814853.dir/build.make CMakeFiles/cmTryCompileExec222814853.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec222814853.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec222814853.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec222814853
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec222814853.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin    CMakeFiles/cmTryCompileExec222814853.dir/CheckFunctionExists.c.o  -o cmTryCompileExec222814853 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1676207125/fast"
make -f CMakeFiles/cmTryCompileExec1676207125.dir/build.make CMakeFiles/cmTryCompileExec1676207125.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1676207125.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -o CMakeFiles/cmTryCompileExec1676207125.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1676207125
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1676207125.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin    CMakeFiles/cmTryCompileExec1676207125.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1676207125 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec364524331/fast"
make -f CMakeFiles/cmTryCompileExec364524331.dir/build.make CMakeFiles/cmTryCompileExec364524331.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec364524331.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -o CMakeFiles/cmTryCompileExec364524331.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec364524331
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec364524331.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin    CMakeFiles/cmTryCompileExec364524331.dir/CheckFunctionExists.c.o  -o cmTryCompileExec364524331 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2424330875/fast"
make -f CMakeFiles/cmTryCompileExec2424330875.dir/build.make CMakeFiles/cmTryCompileExec2424330875.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2424330875.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2424330875.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2424330875
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2424330875.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin    CMakeFiles/cmTryCompileExec2424330875.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2424330875 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1498253069/fast"
make -f CMakeFiles/cmTryCompileExec1498253069.dir/build.make CMakeFiles/cmTryCompileExec1498253069.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1498253069.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -o CMakeFiles/cmTryCompileExec1498253069.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1498253069
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1498253069.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin    CMakeFiles/cmTryCompileExec1498253069.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1498253069 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3636849466/fast"
make -f CMakeFiles/cmTryCompileExec3636849466.dir/build.make CMakeFiles/cmTryCompileExec3636849466.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3636849466.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3636849466.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3636849466
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3636849466.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin    CMakeFiles/cmTryCompileExec3636849466.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3636849466 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1529021994/fast"
make -f CMakeFiles/cmTryCompileExec1529021994.dir/build.make CMakeFiles/cmTryCompileExec1529021994.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1529021994.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec1529021994.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1529021994
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1529021994.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin    CMakeFiles/cmTryCompileExec1529021994.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1529021994 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec823406222/fast"
make -f CMakeFiles/cmTryCompileExec823406222.dir/build.make CMakeFiles/cmTryCompileExec823406222.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec823406222.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -o CMakeFiles/cmTryCompileExec823406222.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec823406222
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec823406222.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin    CMakeFiles/cmTryCompileExec823406222.dir/CheckFunctionExists.c.o  -o cmTryCompileExec823406222 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2613740463/fast"
make -f CMakeFiles/cmTryCompileExec2613740463.dir/build.make CMakeFiles/cmTryCompileExec2613740463.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2613740463.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2613740463.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2613740463
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2613740463.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin    CMakeFiles/cmTryCompileExec2613740463.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2613740463 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec701044223/fast"
make -f CMakeFiles/cmTryCompileExec701044223.dir/build.make CMakeFiles/cmTryCompileExec701044223.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec701044223.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec701044223.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec701044223
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec701044223.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin    CMakeFiles/cmTryCompileExec701044223.dir/CheckFunctionExists.c.o  -o cmTryCompileExec701044223 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1921863019/fast"
make -f CMakeFiles/cmTryCompileExec1921863019.dir/build.make CMakeFiles/cmTryCompileExec1921863019.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1921863019.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec1921863019.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1921863019
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1921863019.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin    CMakeFiles/cmTryCompileExec1921863019.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1921863019 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1395239767/fast"
make -f CMakeFiles/cmTryCompileExec1395239767.dir/build.make CMakeFiles/cmTryCompileExec1395239767.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1395239767.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -o CMakeFiles/cmTryCompileExec1395239767.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1395239767
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1395239767.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin    CMakeFiles/cmTryCompileExec1395239767.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1395239767 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3219217864/fast"
make -f CMakeFiles/cmTryCompileExec3219217864.dir/build.make CMakeFiles/cmTryCompileExec3219217864.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3219217864.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec3219217864.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3219217864
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3219217864.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin    CMakeFiles/cmTryCompileExec3219217864.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3219217864 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2934920576/fast"
make -f CMakeFiles/cmTryCompileExec2934920576.dir/build.make CMakeFiles/cmTryCompileExec2934920576.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2934920576.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec2934920576.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2934920576
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2934920576.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin    CMakeFiles/cmTryCompileExec2934920576.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2934920576 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1558683521/fast"
make -f CMakeFiles/cmTryCompileExec1558683521.dir/build.make CMakeFiles/cmTryCompileExec1558683521.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1558683521.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -o CMakeFiles/cmTryCompileExec1558683521.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1558683521
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1558683521.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin    CMakeFiles/cmTryCompileExec1558683521.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1558683521 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4172986287/fast"
make -f CMakeFiles/cmTryCompileExec4172986287.dir/build.make CMakeFiles/cmTryCompileExec4172986287.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4172986287.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -o CMakeFiles/cmTryCompileExec4172986287.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4172986287
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4172986287.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin    CMakeFiles/cmTryCompileExec4172986287.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4172986287 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1872030900/fast"
make -f CMakeFiles/cmTryCompileExec1872030900.dir/build.make CMakeFiles/cmTryCompileExec1872030900.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1872030900.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec1872030900.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1872030900
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1872030900.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin    CMakeFiles/cmTryCompileExec1872030900.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1872030900 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1369394136/fast"
make -f CMakeFiles/cmTryCompileExec1369394136.dir/build.make CMakeFiles/cmTryCompileExec1369394136.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1369394136.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1369394136.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1369394136
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1369394136.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin    CMakeFiles/cmTryCompileExec1369394136.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1369394136 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1244462605/fast"
make -f CMakeFiles/cmTryCompileExec1244462605.dir/build.make CMakeFiles/cmTryCompileExec1244462605.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1244462605.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -o CMakeFiles/cmTryCompileExec1244462605.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1244462605
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1244462605.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin    CMakeFiles/cmTryCompileExec1244462605.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1244462605 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec790826475/fast"
make -f CMakeFiles/cmTryCompileExec790826475.dir/build.make CMakeFiles/cmTryCompileExec790826475.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec790826475.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec790826475.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec790826475
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec790826475.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin    CMakeFiles/cmTryCompileExec790826475.dir/CheckFunctionExists.c.o  -o cmTryCompileExec790826475 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4155461430/fast"
make -f CMakeFiles/cmTryCompileExec4155461430.dir/build.make CMakeFiles/cmTryCompileExec4155461430.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4155461430.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec4155461430.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4155461430
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4155461430.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin    CMakeFiles/cmTryCompileExec4155461430.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4155461430 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3648574851/fast"
make -f CMakeFiles/cmTryCompileExec3648574851.dir/build.make CMakeFiles/cmTryCompileExec3648574851.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3648574851.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec3648574851.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3648574851
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3648574851.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin    CMakeFiles/cmTryCompileExec3648574851.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3648574851 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2320938006/fast"
make -f CMakeFiles/cmTryCompileExec2320938006.dir/build.make CMakeFiles/cmTryCompileExec2320938006.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2320938006.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -o CMakeFiles/cmTryCompileExec2320938006.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2320938006
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2320938006.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin    CMakeFiles/cmTryCompileExec2320938006.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2320938006 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wcsnrtombs exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec596008638/fast"
make -f CMakeFiles/cmTryCompileExec596008638.dir/build.make CMakeFiles/cmTryCompileExec596008638.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec596008638.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin   -o CMakeFiles/cmTryCompileExec596008638.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec596008638
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec596008638.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin    CMakeFiles/cmTryCompileExec596008638.dir/CheckFunctionExists.c.o  -o cmTryCompileExec596008638 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4060190918/fast"
make -f CMakeFiles/cmTryCompileExec4060190918.dir/build.make CMakeFiles/cmTryCompileExec4060190918.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4060190918.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec4060190918.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4060190918
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4060190918.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin    CMakeFiles/cmTryCompileExec4060190918.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4060190918 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3124428334/fast"
make -f CMakeFiles/cmTryCompileExec3124428334.dir/build.make CMakeFiles/cmTryCompileExec3124428334.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3124428334.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -o CMakeFiles/cmTryCompileExec3124428334.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3124428334
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3124428334.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin    CMakeFiles/cmTryCompileExec3124428334.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3124428334 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2740102312/fast"
make -f CMakeFiles/cmTryCompileExec2740102312.dir/build.make CMakeFiles/cmTryCompileExec2740102312.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2740102312.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -o CMakeFiles/cmTryCompileExec2740102312.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2740102312
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2740102312.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin    CMakeFiles/cmTryCompileExec2740102312.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2740102312 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec342620890/fast"
make -f CMakeFiles/cmTryCompileExec342620890.dir/build.make CMakeFiles/cmTryCompileExec342620890.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec342620890.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec342620890.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec342620890
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec342620890.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin    CMakeFiles/cmTryCompileExec342620890.dir/CheckFunctionExists.c.o  -o cmTryCompileExec342620890 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2984951883/fast"
make -f CMakeFiles/cmTryCompileExec2984951883.dir/build.make CMakeFiles/cmTryCompileExec2984951883.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2984951883.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec2984951883.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2984951883
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2984951883.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin    CMakeFiles/cmTryCompileExec2984951883.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2984951883 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1807394048/fast"
make -f CMakeFiles/cmTryCompileExec1807394048.dir/build.make CMakeFiles/cmTryCompileExec1807394048.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1807394048.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec1807394048.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1807394048
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1807394048.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READDIR_R    CMakeFiles/cmTryCompileExec1807394048.dir/src.c.o  -o cmTryCompileExec1807394048 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2284452573/fast"
make -f CMakeFiles/cmTryCompileExec2284452573.dir/build.make CMakeFiles/cmTryCompileExec2284452573.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2284452573.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec2284452573.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2284452573
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2284452573.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_READLINKAT    CMakeFiles/cmTryCompileExec2284452573.dir/src.c.o  -o cmTryCompileExec2284452573 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1584380276/fast"
make -f CMakeFiles/cmTryCompileExec1584380276.dir/build.make CMakeFiles/cmTryCompileExec1584380276.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1584380276.dir/src.c.o
/usr/bin/gcc   -w  -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec1584380276.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1584380276
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1584380276.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DMAJOR_IN_SYSMACROS    CMakeFiles/cmTryCompileExec1584380276.dir/src.c.o  -o cmTryCompileExec1584380276 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec112792907/fast"
make -f CMakeFiles/cmTryCompileExec112792907.dir/build.make CMakeFiles/cmTryCompileExec112792907.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec112792907.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec112792907.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec112792907
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec112792907.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec112792907.dir/CheckSymbolExists.c.o  -o cmTryCompileExec112792907 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4184550527/fast"
make -f CMakeFiles/cmTryCompileExec4184550527.dir/build.make CMakeFiles/cmTryCompileExec4184550527.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4184550527.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4184550527.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4184550527
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4184550527.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4184550527.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4184550527 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3659512264/fast"
make -f CMakeFiles/cmTryCompileExec3659512264.dir/build.make CMakeFiles/cmTryCompileExec3659512264.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3659512264.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3659512264.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3659512264
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3659512264.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3659512264.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3659512264 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4023081269/fast"
make -f CMakeFiles/cmTryCompileExec4023081269.dir/build.make CMakeFiles/cmTryCompileExec4023081269.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4023081269.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4023081269.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4023081269
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4023081269.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4023081269.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4023081269 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3505722126/fast"
make -f CMakeFiles/cmTryCompileExec3505722126.dir/build.make CMakeFiles/cmTryCompileExec3505722126.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3505722126.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3505722126.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3505722126
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3505722126.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3505722126.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3505722126 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1242496088/fast"
make -f CMakeFiles/cmTryCompileExec1242496088.dir/build.make CMakeFiles/cmTryCompileExec1242496088.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1242496088.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1242496088.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1242496088
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1242496088.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1242496088.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1242496088 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4252670002/fast"
make -f CMakeFiles/cmTryCompileExec4252670002.dir/build.make CMakeFiles/cmTryCompileExec4252670002.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4252670002.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4252670002.dir/CheckSymbolExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4252670002
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4252670002.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4252670002.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4252670002 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

File /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec978535842/fast"
make -f CMakeFiles/cmTryCompileExec978535842.dir/build.make CMakeFiles/cmTryCompileExec978535842.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec978535842.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec978535842.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec978535842
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec978535842.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_TM_TM_GMTOFF    CMakeFiles/cmTryCompileExec978535842.dir/src.c.o  -o cmTryCompileExec978535842 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec539423825/fast"
make -f CMakeFiles/cmTryCompileExec539423825.dir/build.make CMakeFiles/cmTryCompileExec539423825.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec539423825.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec539423825.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec539423825
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec539423825.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC    CMakeFiles/cmTryCompileExec539423825.dir/src.c.o  -o cmTryCompileExec539423825 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1573223603/fast"
make -f CMakeFiles/cmTryCompileExec1573223603.dir/build.make CMakeFiles/cmTryCompileExec1573223603.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1573223603.dir/src.c.o
/usr/bin/gcc   -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec1573223603.dir/src.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1573223603
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1573223603.dir/link.txt --verbose=1
/usr/bin/gcc    -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE    CMakeFiles/cmTryCompileExec1573223603.dir/src.c.o  -o cmTryCompileExec1573223603 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4241718861/fast"
make -f CMakeFiles/cmTryCompileExec4241718861.dir/build.make CMakeFiles/cmTryCompileExec4241718861.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4241718861.dir/SIZE_OF_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4241718861.dir/SIZE_OF_SHORT.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec4241718861
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4241718861.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4241718861.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec4241718861 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec804643406/fast"
make -f CMakeFiles/cmTryCompileExec804643406.dir/build.make CMakeFiles/cmTryCompileExec804643406.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec804643406.dir/SIZE_OF_INT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec804643406.dir/SIZE_OF_INT.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec804643406
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec804643406.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec804643406.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec804643406 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1826589396/fast"
make -f CMakeFiles/cmTryCompileExec1826589396.dir/build.make CMakeFiles/cmTryCompileExec1826589396.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1826589396.dir/SIZE_OF_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1826589396.dir/SIZE_OF_LONG.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec1826589396
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1826589396.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1826589396.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec1826589396 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec608641964/fast"
make -f CMakeFiles/cmTryCompileExec608641964.dir/build.make CMakeFiles/cmTryCompileExec608641964.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec608641964.dir/SIZE_OF_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec608641964.dir/SIZE_OF_LONG_LONG.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec608641964
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec608641964.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec608641964.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec608641964 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2689189430/fast"
make -f CMakeFiles/cmTryCompileExec2689189430.dir/build.make CMakeFiles/cmTryCompileExec2689189430.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2689189430.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2689189430.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2689189430
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2689189430.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2689189430.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2689189430 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2058377581/fast"
make -f CMakeFiles/cmTryCompileExec2058377581.dir/build.make CMakeFiles/cmTryCompileExec2058377581.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2058377581.dir/SIZE_OF_UNSIGNED.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2058377581.dir/SIZE_OF_UNSIGNED.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec2058377581
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2058377581.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2058377581.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec2058377581 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2057204460/fast"
make -f CMakeFiles/cmTryCompileExec2057204460.dir/build.make CMakeFiles/cmTryCompileExec2057204460.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2057204460.dir/SIZE_OF_UNSIGNED_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2057204460.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec2057204460
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2057204460.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2057204460.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec2057204460 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2921876913/fast"
make -f CMakeFiles/cmTryCompileExec2921876913.dir/build.make CMakeFiles/cmTryCompileExec2921876913.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2921876913.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2921876913.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec2921876913
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2921876913.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2921876913.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec2921876913 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1769384705/fast"
make -f CMakeFiles/cmTryCompileExec1769384705.dir/build.make CMakeFiles/cmTryCompileExec1769384705.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1769384705.dir/INT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1769384705.dir/INT16_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec1769384705
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1769384705.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1769384705.dir/INT16_T.c.o  -o cmTryCompileExec1769384705 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2682167140/fast"
make -f CMakeFiles/cmTryCompileExec2682167140.dir/build.make CMakeFiles/cmTryCompileExec2682167140.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2682167140.dir/INT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2682167140.dir/INT32_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec2682167140
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2682167140.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2682167140.dir/INT32_T.c.o  -o cmTryCompileExec2682167140 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2207040054/fast"
make -f CMakeFiles/cmTryCompileExec2207040054.dir/build.make CMakeFiles/cmTryCompileExec2207040054.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2207040054.dir/INT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2207040054.dir/INT64_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec2207040054
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2207040054.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2207040054.dir/INT64_T.c.o  -o cmTryCompileExec2207040054 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec978591825/fast"
make -f CMakeFiles/cmTryCompileExec978591825.dir/build.make CMakeFiles/cmTryCompileExec978591825.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec978591825.dir/INTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec978591825.dir/INTMAX_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec978591825
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec978591825.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec978591825.dir/INTMAX_T.c.o  -o cmTryCompileExec978591825 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec45344265/fast"
make -f CMakeFiles/cmTryCompileExec45344265.dir/build.make CMakeFiles/cmTryCompileExec45344265.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec45344265.dir/UINT8_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec45344265.dir/UINT8_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec45344265
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec45344265.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec45344265.dir/UINT8_T.c.o  -o cmTryCompileExec45344265 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1782038441/fast"
make -f CMakeFiles/cmTryCompileExec1782038441.dir/build.make CMakeFiles/cmTryCompileExec1782038441.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1782038441.dir/UINT16_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec1782038441.dir/UINT16_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec1782038441
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1782038441.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec1782038441.dir/UINT16_T.c.o  -o cmTryCompileExec1782038441 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec708109828/fast"
make -f CMakeFiles/cmTryCompileExec708109828.dir/build.make CMakeFiles/cmTryCompileExec708109828.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec708109828.dir/UINT32_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec708109828.dir/UINT32_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec708109828
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec708109828.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec708109828.dir/UINT32_T.c.o  -o cmTryCompileExec708109828 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec375085286/fast"
make -f CMakeFiles/cmTryCompileExec375085286.dir/build.make CMakeFiles/cmTryCompileExec375085286.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec375085286.dir/UINT64_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec375085286.dir/UINT64_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec375085286
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec375085286.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec375085286.dir/UINT64_T.c.o  -o cmTryCompileExec375085286 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4232324175/fast"
make -f CMakeFiles/cmTryCompileExec4232324175.dir/build.make CMakeFiles/cmTryCompileExec4232324175.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4232324175.dir/UINTMAX_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec4232324175.dir/UINTMAX_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec4232324175
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4232324175.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec4232324175.dir/UINTMAX_T.c.o  -o cmTryCompileExec4232324175 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3128685984/fast"
make -f CMakeFiles/cmTryCompileExec3128685984.dir/build.make CMakeFiles/cmTryCompileExec3128685984.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3128685984.dir/DEV_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3128685984.dir/DEV_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec3128685984
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3128685984.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3128685984.dir/DEV_T.c.o  -o cmTryCompileExec3128685984 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3556756204/fast"
make -f CMakeFiles/cmTryCompileExec3556756204.dir/build.make CMakeFiles/cmTryCompileExec3556756204.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3556756204.dir/GID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3556756204.dir/GID_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec3556756204
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3556756204.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3556756204.dir/GID_T.c.o  -o cmTryCompileExec3556756204 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec92186768/fast"
make -f CMakeFiles/cmTryCompileExec92186768.dir/build.make CMakeFiles/cmTryCompileExec92186768.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec92186768.dir/ID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec92186768.dir/ID_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec92186768
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec92186768.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec92186768.dir/ID_T.c.o  -o cmTryCompileExec92186768 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3911091840/fast"
make -f CMakeFiles/cmTryCompileExec3911091840.dir/build.make CMakeFiles/cmTryCompileExec3911091840.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3911091840.dir/MODE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3911091840.dir/MODE_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec3911091840
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3911091840.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3911091840.dir/MODE_T.c.o  -o cmTryCompileExec3911091840 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2127041778/fast"
make -f CMakeFiles/cmTryCompileExec2127041778.dir/build.make CMakeFiles/cmTryCompileExec2127041778.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2127041778.dir/OFF_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2127041778.dir/OFF_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec2127041778
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2127041778.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2127041778.dir/OFF_T.c.o  -o cmTryCompileExec2127041778 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2488202104/fast"
make -f CMakeFiles/cmTryCompileExec2488202104.dir/build.make CMakeFiles/cmTryCompileExec2488202104.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2488202104.dir/SIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2488202104.dir/SIZE_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec2488202104
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2488202104.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2488202104.dir/SIZE_T.c.o  -o cmTryCompileExec2488202104 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3646390370/fast"
make -f CMakeFiles/cmTryCompileExec3646390370.dir/build.make CMakeFiles/cmTryCompileExec3646390370.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3646390370.dir/SSIZE_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3646390370.dir/SSIZE_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec3646390370
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3646390370.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3646390370.dir/SSIZE_T.c.o  -o cmTryCompileExec3646390370 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3216908668/fast"
make -f CMakeFiles/cmTryCompileExec3216908668.dir/build.make CMakeFiles/cmTryCompileExec3216908668.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3216908668.dir/UID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec3216908668.dir/UID_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec3216908668
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3216908668.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec3216908668.dir/UID_T.c.o  -o cmTryCompileExec3216908668 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec312025007/fast"
make -f CMakeFiles/cmTryCompileExec312025007.dir/build.make CMakeFiles/cmTryCompileExec312025007.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec312025007.dir/PID_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec312025007.dir/PID_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec312025007
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec312025007.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec312025007.dir/PID_T.c.o  -o cmTryCompileExec312025007 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2280934740/fast"
make -f CMakeFiles/cmTryCompileExec2280934740.dir/build.make CMakeFiles/cmTryCompileExec2280934740.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2280934740.dir/INTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2280934740.dir/INTPTR_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec2280934740
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2280934740.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2280934740.dir/INTPTR_T.c.o  -o cmTryCompileExec2280934740 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2628684330/fast"
make -f CMakeFiles/cmTryCompileExec2628684330.dir/build.make CMakeFiles/cmTryCompileExec2628684330.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2628684330.dir/UINTPTR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2628684330.dir/UINTPTR_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec2628684330
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2628684330.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2628684330.dir/UINTPTR_T.c.o  -o cmTryCompileExec2628684330 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2031433216/fast"
make -f CMakeFiles/cmTryCompileExec2031433216.dir/build.make CMakeFiles/cmTryCompileExec2031433216.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2031433216.dir/SIZEOF_WCHAR_T.c.o
/usr/bin/gcc   -w     -o CMakeFiles/cmTryCompileExec2031433216.dir/SIZEOF_WCHAR_T.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec2031433216
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2031433216.dir/link.txt --verbose=1
/usr/bin/gcc    -w      CMakeFiles/cmTryCompileExec2031433216.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec2031433216 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3106602689/fast"
make -f CMakeFiles/cmTryCompileExec3106602689.dir/build.make CMakeFiles/cmTryCompileExec3106602689.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3106602689.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3106602689.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:17: error: md5.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:156: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:117: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:124: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:132: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1237: error: ‘__archive_libc_md5init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1238: error: ‘__archive_libc_md5update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1239: error: ‘__archive_libc_md5final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3106602689.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3106602689/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3516599380/fast"
make -f CMakeFiles/cmTryCompileExec3516599380.dir/build.make CMakeFiles/cmTryCompileExec3516599380.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3516599380.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3516599380.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:20: error: rmd160.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:172: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_rmd160_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:357: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:358: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:293: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:300: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:308: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1268: error: ‘__archive_libc_ripemd160init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1269: error: ‘__archive_libc_ripemd160update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1270: error: ‘__archive_libc_ripemd160final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3516599380.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3516599380/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3102285455/fast"
make -f CMakeFiles/cmTryCompileExec3102285455.dir/build.make CMakeFiles/cmTryCompileExec3102285455.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3102285455.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3102285455.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:18: error: sha1.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:184: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:419: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:426: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:434: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1291: error: ‘__archive_libc_sha1init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1292: error: ‘__archive_libc_sha1update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1293: error: ‘__archive_libc_sha1final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3102285455.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3102285455/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1230411303/fast"
make -f CMakeFiles/cmTryCompileExec1230411303.dir/build.make CMakeFiles/cmTryCompileExec1230411303.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1230411303.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1230411303.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:200: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:595: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:602: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:610: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1322: error: ‘__archive_libc_sha256init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1323: error: ‘__archive_libc_sha256update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1324: error: ‘__archive_libc_sha256final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1230411303.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1230411303/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4022077854/fast"
make -f CMakeFiles/cmTryCompileExec4022077854.dir/build.make CMakeFiles/cmTryCompileExec4022077854.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4022077854.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4022077854.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:220: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:814: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:821: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:829: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1361: error: ‘__archive_libc_sha384init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1362: error: ‘__archive_libc_sha384update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1363: error: ‘__archive_libc_sha384final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec4022077854.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec4022077854/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4266945631/fast"
make -f CMakeFiles/cmTryCompileExec4266945631.dir/build.make CMakeFiles/cmTryCompileExec4266945631.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4266945631.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4266945631.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:238: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1009: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1016: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1024: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1396: error: ‘__archive_libc_sha512init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1397: error: ‘__archive_libc_sha512update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1398: error: ‘__archive_libc_sha512final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec4266945631.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec4266945631/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3399241916/fast"
make -f CMakeFiles/cmTryCompileExec3399241916.dir/build.make CMakeFiles/cmTryCompileExec3399241916.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3399241916.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3399241916.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:202: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:619: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:626: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:634: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1326: error: ‘__archive_libc2_sha256init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1327: error: ‘__archive_libc2_sha256update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1328: error: ‘__archive_libc2_sha256final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3399241916.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3399241916/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2744858982/fast"
make -f CMakeFiles/cmTryCompileExec2744858982.dir/build.make CMakeFiles/cmTryCompileExec2744858982.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2744858982.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2744858982.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:222: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:838: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:845: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:853: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1365: error: ‘__archive_libc2_sha384init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1366: error: ‘__archive_libc2_sha384update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1367: error: ‘__archive_libc2_sha384final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec2744858982.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec2744858982/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1569402517/fast"
make -f CMakeFiles/cmTryCompileExec1569402517.dir/build.make CMakeFiles/cmTryCompileExec1569402517.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1569402517.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1569402517.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:240: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1033: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1040: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1048: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1400: error: ‘__archive_libc2_sha512init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1401: error: ‘__archive_libc2_sha512update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1402: error: ‘__archive_libc2_sha512final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1569402517.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1569402517/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3595005500/fast"
make -f CMakeFiles/cmTryCompileExec3595005500.dir/build.make CMakeFiles/cmTryCompileExec3595005500.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3595005500.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3595005500.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:204: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:643: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:650: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:658: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1330: error: ‘__archive_libc3_sha256init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1331: error: ‘__archive_libc3_sha256update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1332: error: ‘__archive_libc3_sha256final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3595005500.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3595005500/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1160424081/fast"
make -f CMakeFiles/cmTryCompileExec1160424081.dir/build.make CMakeFiles/cmTryCompileExec1160424081.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1160424081.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1160424081.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:224: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:862: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:869: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:877: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1369: error: ‘__archive_libc3_sha384init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1370: error: ‘__archive_libc3_sha384update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1371: error: ‘__archive_libc3_sha384final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1160424081.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1160424081/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3372674498/fast"
make -f CMakeFiles/cmTryCompileExec3372674498.dir/build.make CMakeFiles/cmTryCompileExec3372674498.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3372674498.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3372674498.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: error: sha2.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:242: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1057: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1064: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1072: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1404: error: ‘__archive_libc3_sha512init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1405: error: ‘__archive_libc3_sha512update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1406: error: ‘__archive_libc3_sha512final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3372674498.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3372674498/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2395168279/fast"
make -f CMakeFiles/cmTryCompileExec2395168279.dir/build.make CMakeFiles/cmTryCompileExec2395168279.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2395168279.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2395168279.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:160: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:165: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:172: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:180: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1245: error: ‘__archive_libsystem_md5init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1246: error: ‘__archive_libsystem_md5update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1247: error: ‘__archive_libsystem_md5final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec2395168279.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec2395168279/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1427503179/fast"
make -f CMakeFiles/cmTryCompileExec1427503179.dir/build.make CMakeFiles/cmTryCompileExec1427503179.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1427503179.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1427503179.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:188: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:467: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:474: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:482: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1299: error: ‘__archive_libsystem_sha1init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1300: error: ‘__archive_libsystem_sha1update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1301: error: ‘__archive_libsystem_sha1final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1427503179.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1427503179/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4207842193/fast"
make -f CMakeFiles/cmTryCompileExec4207842193.dir/build.make CMakeFiles/cmTryCompileExec4207842193.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4207842193.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4207842193.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:208: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:691: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:698: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:706: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1338: error: ‘__archive_libsystem_sha256init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1339: error: ‘__archive_libsystem_sha256update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1340: error: ‘__archive_libsystem_sha256final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec4207842193.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec4207842193/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1014571663/fast"
make -f CMakeFiles/cmTryCompileExec1014571663.dir/build.make CMakeFiles/cmTryCompileExec1014571663.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1014571663.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1014571663.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:226: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha384_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:366: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:367: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:886: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:893: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:901: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1373: error: ‘__archive_libsystem_sha384init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1374: error: ‘__archive_libsystem_sha384update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1375: error: ‘__archive_libsystem_sha384final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1014571663.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1014571663/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec300295045/fast"
make -f CMakeFiles/cmTryCompileExec300295045.dir/build.make CMakeFiles/cmTryCompileExec300295045.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec300295045.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec300295045.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: error: CommonCrypto/CommonDigest.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:246: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1105: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1112: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1120: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1412: error: ‘__archive_libsystem_sha512init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1413: error: ‘__archive_libsystem_sha512update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1414: error: ‘__archive_libsystem_sha512final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec300295045.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec300295045/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1381819846/fast"
make -f CMakeFiles/cmTryCompileExec1381819846.dir/build.make CMakeFiles/cmTryCompileExec1381819846.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1381819846.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1381819846.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:17: error: md5.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:158: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_md5_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:354: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:355: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:141: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:148: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:156: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1241: error: ‘__archive_libmd_md5init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1242: error: ‘__archive_libmd_md5update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1243: error: ‘__archive_libmd_md5final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1381819846.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1381819846/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4235332030/fast"
make -f CMakeFiles/cmTryCompileExec4235332030.dir/build.make CMakeFiles/cmTryCompileExec4235332030.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4235332030.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4235332030.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:20: error: ripemd.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:174: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_rmd160_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:357: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:358: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:317: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:324: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:332: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1272: error: ‘__archive_libmd_ripemd160init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1273: error: ‘__archive_libmd_ripemd160update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1274: error: ‘__archive_libmd_ripemd160final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec4235332030.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec4235332030/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3138741369/fast"
make -f CMakeFiles/cmTryCompileExec3138741369.dir/build.make CMakeFiles/cmTryCompileExec3138741369.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3138741369.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3138741369.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:17: error: sha.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:186: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha1_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:360: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:361: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:443: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:450: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:458: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1295: error: ‘__archive_libmd_sha1init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1296: error: ‘__archive_libmd_sha1update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1297: error: ‘__archive_libmd_sha1final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec3138741369.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec3138741369/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1315558579/fast"
make -f CMakeFiles/cmTryCompileExec1315558579.dir/build.make CMakeFiles/cmTryCompileExec1315558579.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1315558579.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1315558579.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:20: error: sha256.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:206: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha256_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:363: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:364: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:667: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:674: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:682: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1334: error: ‘__archive_libmd_sha256init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1335: error: ‘__archive_libmd_sha256update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1336: error: ‘__archive_libmd_sha256final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec1315558579.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec1315558579/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec338206907/fast"
make -f CMakeFiles/cmTryCompileExec338206907.dir/build.make CMakeFiles/cmTryCompileExec338206907.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec338206907.dir/check_crypto_md.c.o
/usr/bin/gcc   -w   -I/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive -I/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec338206907.dir/check_crypto_md.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:20: error: sha512.h: No such file or directory
In file included from /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:244: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘archive_sha512_ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:369: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:370: error: expected ‘;’ before ‘int’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1081: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1088: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1096: error: expected ‘)’ before ‘*’ token
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1408: error: ‘__archive_libmd_sha512init’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1409: error: ‘__archive_libmd_sha512update’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1410: error: ‘__archive_libmd_sha512final’ undeclared here (not in a function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c: In function ‘main’:
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: ‘archive__ctx’ undeclared (first use in this function)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: (Each undeclared identifier is reported only once
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: for each function it appears in.)
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1438: error: expected ‘;’ before ‘ctx’
/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/check_crypto_md.c:1439: error: ‘ctx’ undeclared (first use in this function)
make[1]: *** [CMakeFiles/cmTryCompileExec338206907.dir/check_crypto_md.c.o] Error 1
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
make: *** [cmTryCompileExec338206907/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2837554044/fast"
make -f CMakeFiles/cmTryCompileExec2837554044.dir/build.make CMakeFiles/cmTryCompileExec2837554044.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2837554044.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2837554044.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2837554044
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2837554044.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec2837554044.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2837554044 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the function wsyncup exists in the /usr/lib/libcurses.so passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec170616067/fast"
make -f CMakeFiles/cmTryCompileExec170616067.dir/build.make CMakeFiles/cmTryCompileExec170616067.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec170616067.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=wsyncup   -o CMakeFiles/cmTryCompileExec170616067.dir/CheckFunctionExists.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec170616067
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec170616067.dir/link.txt --verbose=1
/usr/bin/gcc     -DCHECK_FUNCTION_EXISTS=wsyncup    CMakeFiles/cmTryCompileExec170616067.dir/CheckFunctionExists.c.o  -o cmTryCompileExec170616067 -rdynamic -lcurses 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1682832148/fast"
make -f CMakeFiles/cmTryCompileExec1682832148.dir/build.make CMakeFiles/cmTryCompileExec1682832148.dir/build
make[1]: Entering directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_progress_report /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1682832148.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1682832148.dir/CheckIncludeFile.c.o   -c /home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1682832148
/home/ashwini/Documents/driving_python/image_processing/cmake/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1682832148.dir/link.txt --verbose=1
/usr/bin/gcc         CMakeFiles/cmTryCompileExec1682832148.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1682832148 -rdynamic 
make[1]: Leaving directory `/home/ashwini/Documents/driving_python/image_processing/cmake/CMakeFiles/CMakeTmp'


Looking for a Fortran compiler passed with the following output:
-- The Fortran compiler identification is GNU
-- Check for working Fortran compiler: /usr/bin/f95
-- Check for working Fortran compiler: /usr/bin/f95  -- works
-- Detecting Fortran compiler ABI info
-- Detecting Fortran compiler ABI info - done
-- Checking whether /usr/bin/f95 supports Fortran 90
-- Checking whether /usr/bin/f95 supports Fortran 90 -- yes
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ashwini/Documents/driving_python/image_processing/cmake/Tests/CMakeFiles/CheckFortran

